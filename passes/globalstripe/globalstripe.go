package globalstripe

import (
	"fmt"
	"go/types"
	"golang.org/x/tools/go/analysis/passes/buildssa"
	"golang.org/x/tools/go/analysis/passes/inspect"
	"strings"
	"golang.org/x/tools/go/ssa"
	"golang.org/x/tools/go/analysis"
)
var doc = `If you need to run stripe with multiple API keys, you'll need to use the stripe client and 
not the global functions. This vet tool will check for those function calls and give you a warning.`

var Analyzer = &analysis.Analyzer{
	Name: "globalstripe",
	Doc:  doc,
	Requires: []*analysis.Analyzer{
		inspect.Analyzer,
		buildssa.Analyzer,
	},
	Run:  run,
}

var stripeFunctions = []string{
	"token.New",
	"token.Get",
	"order.New",
	"order.Get",
	"order.Update",
	"order.Pay",
	"order.Return",
	"order.List",
	"balancetransaction.Get",
	"balancetransaction.List",
	"reporting/reporttype.Get",
	"reporting/reporttype.List",
	"reporting/reportrun.New",
	"reporting/reportrun.Get",
	"reporting/reportrun.List",
	"setupattempt.List",
	"customerbalancetransaction.New",
	"customerbalancetransaction.Get",
	"customerbalancetransaction.Update",
	"customerbalancetransaction.List",
	"setupintent.New",
	"setupintent.Get",
	"setupintent.Update",
	"setupintent.Cancel",
	"setupintent.Confirm",
	"setupintent.List",
	"paymentmethod.New",
	"paymentmethod.Get",
	"paymentmethod.Update",
	"paymentmethod.Attach",
	"paymentmethod.Detach",
	"paymentmethod.List",
	"card.New",
	"card.Get",
	"card.Update",
	"card.Del",
	"card.List",
	"oauth.AuthorizeURL",
	"oauth.New",
	"oauth.Del",
	"topup.Cancel",
	"topup.New",
	"topup.Get",
	"topup.Update",
	"topup.List",
	"charge.New",
	"charge.Get",
	"charge.Update",
	"charge.Capture",
	"charge.List",
	"applepaydomain.New",
	"applepaydomain.Get",
	"applepaydomain.Del",
	"applepaydomain.List",
	"fee.Get",
	"fee.List",
	"sourcetransaction.List",
	"ephemeralkey.New",
	"ephemeralkey.Del",
	"identity/verificationreport.Get",
	"identity/verificationreport.List",
	"identity/verificationsession.New",
	"identity/verificationsession.Get",
	"identity/verificationsession.Update",
	"identity/verificationsession.Cancel",
	"identity/verificationsession.Redact",
	"identity/verificationsession.List",
	"file.New",
	"file.Get",
	"file.List",
	"quote.New",
	"quote.Get",
	"quote.Update",
	"quote.Accept",
	"quote.Cancel",
	"quote.FinalizeQuote",
	"quote.PDF",
	"quote.List",
	"quote.ListComputedUpfrontLineItems",
	"quote.ListLineItems",
	"person.New",
	"person.Get",
	"person.Update",
	"person.Del",
	"person.List",
	"plan.New",
	"plan.Get",
	"plan.Update",
	"plan.Del",
	"plan.List",
	"orderreturn.Get",
	"orderreturn.List",
	"source.New",
	"source.Get",
	"source.Update",
	"source.Detach",
	"paymentintent.New",
	"paymentintent.Get",
	"paymentintent.Update",
	"paymentintent.Cancel",
	"paymentintent.Capture",
	"paymentintent.Confirm",
	"paymentintent.List",
	"capability.Get",
	"capability.Update",
	"capability.List",
	"usagerecordsummary.List",
	"promotioncode.New",
	"promotioncode.Get",
	"promotioncode.Update",
	"promotioncode.List",
	"issuing/transaction.Get",
	"issuing/transaction.Update",
	"issuing/transaction.List",
	"issuing/card.New",
	"issuing/card.Get",
	"issuing/card.Update",
	"issuing/card.List",
	"issuing/dispute.New",
	"issuing/dispute.Get",
	"issuing/dispute.Submit",
	"issuing/dispute.Update",
	"issuing/dispute.List",
	"issuing/cardholder.New",
	"issuing/cardholder.Get",
	"issuing/cardholder.Update",
	"issuing/cardholder.List",
	"issuing/authorization.Approve",
	"issuing/authorization.Decline",
	"issuing/authorization.Get",
	"issuing/authorization.Update",
	"issuing/authorization.List",
	"invoiceitem.New",
	"invoiceitem.Get",
	"invoiceitem.Update",
	"invoiceitem.Del",
	"invoiceitem.List",
	"transfer.New",
	"transfer.Get",
	"transfer.Update",
	"transfer.List",
	"terminal/reader.New",
	"terminal/reader.Get",
	"terminal/reader.Update",
	"terminal/reader.Del",
	"terminal/reader.List",
	"terminal/location.New",
	"terminal/location.Get",
	"terminal/location.Update",
	"terminal/location.Del",
	"terminal/location.List",
	"terminal/connectiontoken.New",
	"balance.Get",
	"coupon.New",
	"coupon.Get",
	"coupon.Update",
	"coupon.Del",
	"coupon.List",
	"reversal.New",
	"reversal.Get",
	"reversal.Update",
	"reversal.List",
	"product.New",
	"product.Get",
	"product.Update",
	"product.Del",
	"product.List",
	"billingportal/configuration.New",
	"billingportal/configuration.Get",
	"billingportal/configuration.Update",
	"billingportal/configuration.List",
	"billingportal/session.New",
	"countryspec.Get",
	"countryspec.List",
	"dispute.Get",
	"dispute.Update",
	"dispute.Close",
	"dispute.List",
	"checkout/session.New",
	"checkout/session.Get",
	"checkout/session.List",
	"checkout/session.ListLineItems",
	"discount.Del",
	"discount.DelSubscription",
	"mandate.Get",
	"sigma/scheduledqueryrun.Get",
	"sigma/scheduledqueryrun.List",
	"filelink.New",
	"filelink.Get",
	"filelink.Update",
	"filelink.List",
	"sub.New",
	"sub.Get",
	"sub.Update",
	"sub.Cancel",
	"sub.List",
	"price.New",
	"price.Get",
	"price.Update",
	"price.List",
	"subschedule.Cancel",
	"subschedule.Get",
	"subschedule.List",
	"subschedule.New",
	"subschedule.Release",
	"subschedule.Update",
	"paymentsource.New",
	"paymentsource.Get",
	"paymentsource.Update",
	"paymentsource.Del",
	"paymentsource.List",
	"paymentsource.Verify",
	"taxcode.Get",
	"taxcode.List",
	"bankaccount.New",
	"bankaccount.Get",
	"bankaccount.Update",
	"bankaccount.Del",
	"bankaccount.List",
	"review.Get",
	"review.Approve",
	"review.List",
	"accountlink.New",
	"usagerecord.New",
	"taxid.New",
	"taxid.Get",
	"taxid.Del",
	"taxid.List",
	"feerefund.New",
	"feerefund.Get",
	"feerefund.Update",
	"feerefund.List",
	"sku.New",
	"sku.Get",
	"sku.Update",
	"sku.Del",
	"sku.List",
	"webhookendpoint.New",
	"webhookendpoint.Get",
	"webhookendpoint.Update",
	"webhookendpoint.Del",
	"webhookendpoint.List",
	"taxrate.New",
	"taxrate.Get",
	"taxrate.Update",
	"taxrate.Del",
	"taxrate.List",
	"account.New",
	"account.Get",
	"account.GetByID",
	"account.Update",
	"account.Del",
	"account.Reject",
	"account.List",
	"radar/earlyfraudwarning.Get",
	"radar/earlyfraudwarning.List",
	"radar/valuelistitem.New",
	"radar/valuelistitem.Get",
	"radar/valuelistitem.Del",
	"radar/valuelistitem.List",
	"radar/valuelist.New",
	"radar/valuelist.Get",
	"radar/valuelist.Update",
	"radar/valuelist.Del",
	"radar/valuelist.List",
	"subitem.New",
	"subitem.Get",
	"subitem.Update",
	"subitem.Del",
	"subitem.List",
	"loginlink.New",
	"event.Get",
	"event.List",
	"creditnote.New",
	"creditnote.Get",
	"creditnote.Update",
	"creditnote.List",
	"creditnote.ListLines",
	"creditnote.ListPreviewLines",
	"creditnote.Preview",
	"creditnote.VoidCreditNote",
	"refund.New",
	"refund.Get",
	"refund.Update",
	"refund.List",
	"payout.New",
	"payout.Get",
	"payout.Update",
	"payout.Cancel",
	"payout.Reverse",
	"payout.List",
	"customer.New",
	"customer.Get",
	"customer.Update",
	"customer.Del",
	"customer.List",
	"customer.ListPaymentMethods",
	"invoice.New",
	"invoice.Get",
	"invoice.Update",
	"invoice.Del",
	"invoice.FinalizeInvoice",
	"invoice.GetNext",
	"invoice.MarkUncollectible",
	"invoice.Pay",
	"invoice.SendInvoice",
	"invoice.VoidInvoice",
	"invoice.List",
	"invoice.ListLines",
}

func run(pass *analysis.Pass) (interface{}, error) {
	funcs := pass.ResultOf[buildssa.Analyzer].(*buildssa.SSA).SrcFuncs

	// Fast path: if the package doesn't import database/sql,
	// skip the traversal.
	if !imports(pass.Pkg, "/stripe/") {
		return nil, nil
	}

	for _, f := range funcs {
		for _, b := range f.Blocks {
			for i := range b.Instrs {
				call, ok := b.Instrs[i].(ssa.CallInstruction)
				if !ok {
					continue
				}
				common := call.Common()
				if common != nil {
					// skip if it does not contain stripe
					if !strings.Contains(common.Value.String(), "/stripe/stripe-go/") {
						continue
					}

					// check if the call ends with the stripe functions that call getC()
					if found, fun := functionInSlice(common.Value.String(), stripeFunctions); found {
						pass.Report(analysis.Diagnostic{
							Pos:            common.Pos(),
							End:            0,
							Category:       "",
							Message:        fmt.Sprintf("don't use global stripe function: %s", fun),
						})
					}
				}
			}
		}
	}
	return nil, nil
}

func functionInSlice(a string, list []string) (bool, string) {
	for _, b := range list {
		if strings.HasSuffix(a, b) {
			return true, b
		}
	}
	return false, ""
}

func imports(pkg *types.Package, path string) bool {
	for _, imp := range pkg.Imports() {
		if strings.Contains(imp.Path(), path)  {
			return true
		}
	}
	return false
}